// tb/top_tb.sv
module top_tb;

  localparam int WIDTH = 32;
  localparam int DEPTH = 16;

  logic clk;
  fifo_if #(WIDTH) vif(clk);

  // DUT
  fifo_sync #(.WIDTH(WIDTH), .DEPTH(DEPTH)) dut (
    .clk       (clk),
    .rst_n     (vif.rst_n),
    .in_valid  (vif.in_valid),
    .in_ready  (vif.in_ready),
    .in_data   (vif.in_data),
    .out_valid (vif.out_valid),
    .out_ready (vif.out_ready),
    .out_data  (vif.out_data),
    .full      (),
    .empty     (),
    .count     ()
  );

  // If you're on ModelSim (not full Questa), assertions may not run.
  // You can comment this out for now if you prefer.
  /*
  fifo_assertions #(.DEPTH(DEPTH)) a0 (
    .clk       (clk),
    .rst_n     (vif.rst_n),
    .in_valid  (vif.in_valid),
    .in_ready  (vif.in_ready),
    .out_valid (vif.out_valid),
    .out_ready (vif.out_ready),
    .count     (dut.count)
  );
  */

  // Clock
  initial clk = 0;
  always #5 clk = ~clk;

  // Simple reference model queue
  logic [WIDTH-1:0] q[$];
  logic [WIDTH-1:0] exp;
  bit rv_in;
bit rv_out;
logic [WIDTH-1:0] rd;


  // Reset
  initial begin
    vif.rst_n      = 0;
    vif.in_valid   = 0;
    vif.in_data    = '0;
    vif.out_ready  = 0;
    repeat (5) @(posedge clk);
    vif.rst_n = 1;
  end

  // Utility task: drive one cycle of stimulus *before* the active clock edge.
  task drive_cycle(input bit in_v, input logic [WIDTH-1:0] in_d, input bit out_r);
    @(negedge clk);
    vif.in_valid  = in_v;     // BLOCKING assignments for cycle-accurate driving
    vif.in_data   = in_d;
    vif.out_ready = out_r;
  endtask

  // Push task: handshake-aware single push
  task drive_push(input logic [WIDTH-1:0] val);
    // Hold out_ready low during pushes to keep waveforms simpler/cleaner
    do begin
      drive_cycle(1'b1, val, 1'b0);
      @(posedge clk);
    end while (!vif.in_ready);

    // Accepted on that posedge
    q.push_back(val);

    // Deassert in_valid next cycle
    drive_cycle(1'b0, '0, 1'b0);
    @(posedge clk);
  endtask

  // Main stimulus + checking
  initial begin
    wait(vif.rst_n);

    // Phase 1: push 10 items with no popping
    for (int i = 0; i < 10; i++) begin
      drive_push(i);
    end

    // Phase 2: allow popping
    //drive_cycle(1'b0, '0, 1'b1);
    //repeat (5) @(posedge clk);

    // Phase 3: random traffic with correct timing (drive on negedge, sample/check on posedge)
    for (int cyc = 0; cyc < 200; cyc++) begin
      rv_in  = $urandom_range(0,1);
rv_out = $urandom_range(0,1);
rd     = $urandom();


      drive_cycle(rv_in, rd, rv_out);

      @(posedge clk);

      // Update reference model based on *the same* handshake the DUT saw at this posedge
      if (vif.in_valid && vif.in_ready) begin
        q.push_back(vif.in_data);
      end

      if (vif.out_valid && vif.out_ready) begin
        if (q.size() == 0) begin
          $fatal(1, "UNDERFLOW in reference model: DUT popped when queue empty.");
        end
        exp = q.pop_front();
        if (vif.out_data !== exp) begin
          $fatal(1, "DATA MISMATCH: exp=%h got=%h", exp, vif.out_data);
        end
      end
    end

    $display("TEST PASSED");
    $finish;
  end

endmodule
